y = "Phosphorus Flux (g P / m2 / year)",
x = "Treatment",
fill = "Flux Type"
) +
scale_fill_manual(values = c("P_Mineralization_Supply" = "#E69F00", "Plant_Uptake" = "#56B4E9"),
labels = c("Soil Supply (Microbes)", "Tree Uptake")) +
theme_minimal() +
theme(text = element_text(size = 14))
# Print the numbers to see the "Stealing"
print(final_data %>%
group_by(Trt) %>%
summarise(
Avg_Supply = mean(P_Mineralization_Supply),
Avg_Tree_Uptake = mean(Plant_Uptake),
Avg_Stolen_P = mean(Microbial_Stealing)
))
View(leaf_re)
# Print the final numerical result (Mean Time-Averaged Budget)
print(final_data %>%
group_by(Trt) %>%
summarise(
Avg_Supply = mean(P_Mineralization_Supply),
Avg_Tree_Uptake = mean(Plant_Uptake),
Avg_Stolen_P = mean(Microbial_Stealing),
.groups = 'drop'
))
library(tidyverse)
library(lubridate)
# 1. SETUP -------------------------------------------------------------------
# Define which rings are Elevated CO2 (eCO2) and Ambient (aCO2)
trt_map <- data.frame(
Ring = factor(c(1, 2, 3, 4, 5, 6)),
Trt = c("eCO2", "aCO2", "aCO2", "eCO2", "eCO2", "aCO2")
)
# --- CORRECTED FUNCTION FOR ANNUAL FLUX CALCULATION ---
# This function implements the CORRECT methodology: Summing (Daily Flux * Days in Period)
#
# is_mg_unit: TRUE if the input unit is mg/m2/d (needs division by 1000); FALSE if g/m2/d (no conversion).
clean_flux <- function(filepath, col_name, type_name, is_mg_unit = TRUE) {
conversion_factor = ifelse(is_mg_unit, 0.001, 1)
read_csv(filepath, show_col_types = FALSE) %>%
mutate(
Ring = factor(Ring),
# Use Date or Start_date to determine the Year
Year = year(coalesce(Date, Start_date))
) %>%
# CORRECTED TIME WINDOW: Use full 6 years as per the paper (2013-2018)
filter(Year >= 2013 & Year <= 2018) %>%
# 1. Calculate TOTAL FLUX for each measurement period
mutate(
# The corrected calculation: (Daily Flux * Days in period) * (Unit Conversion)
Periodic_Total_g = get(col_name) * Days * conversion_factor
) %>%
# 2. Sum the periodic totals to get the Annual Flux per Ring
group_by(Year, Ring) %>%
summarise(
Annual_Flux_g = sum(Periodic_Total_g, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(Type = type_name)
}
# 2. LOAD & CLEAN DATA (Using corrected function) ----------------------------
# A. Plant Demand (P Production Fluxes)
# Units assumed to be mg/m2/d for retranslocation, but may vary. We set is_mg_unit=FALSE
# for canopy and wood P flux as they are often reported in g. You may need to verify.
wood_p_prod <- clean_flux("wood_c_production_flux.csv", "wood_c_production_flux", "Wood_P_Prod", is_mg_unit = FALSE) # Check units
leaf_p_prod <- clean_flux("canopy_c_production_flux.csv", "leaf_flux", "Canopy_P_Prod", is_mg_unit = FALSE) # Proxy for P production flux in paper (leaf flux)
root_p_prod <- clean_flux("fineroot_p_production_flux.csv", "fineroot_p_flux_mg_m2_d", "Roots_P_Prod", is_mg_unit = TRUE)
# 1. SETUP -------------------------------------------------------------------
library(tidyverse)
library(lubridate)
setwd("C:/Users/augre/Desktop/UPV S1/Data/2025Bgroup-phosphorusCO2/Flux_data")
# Define which rings are Elevated CO2 (eCO2) and Ambient (aCO2)
trt_map <- data.frame(
Ring = factor(c(1, 2, 3, 4, 5, 6)),
Trt = c("eCO2", "aCO2", "aCO2", "eCO2", "eCO2", "aCO2")
)
# Function to turn the CSV data into Annual Totals (g P per m2 per year)
# We take the daily average and multiply by 365
clean_flux <- function(filepath, col_name, type_name) {
read_csv(filepath, show_col_types = FALSE) %>%
mutate(Ring = factor(Ring), Year = year(Date)) %>%
filter(Year >= 2013 & Year <= 2016) %>% # Use core study years
group_by(Year, Ring) %>%
summarise(
# The raw data is usually mg/m2/day.
# Formula: Average Daily * 365 days / 1000 (to get grams)
Annual_Flux_g = mean(get(col_name), na.rm = TRUE) * 365 / 1000,
.groups = "drop"
) %>%
mutate(Type = type_name)
}
# 2. LOAD DATA (The Evidence) -----------------------------------------------
# A. Plant Demand (What the tree wants)
# We sum up P used for Wood, Canopy (Leaves), and Fine Roots
wood_p  <- clean_flux("wood_p_flux.csv", "wood_p_flux", "Wood")
leaf_p  <- clean_flux("canopy_p_flux.csv", "canopy_p_flux", "Canopy")
root_p  <- clean_flux("fineroot_p_production_flux.csv", "fineroot_p_flux_mg_m2_d", "Roots")
# B. Plant Recycling (Retranslocation)
# Trees are smart; they suck P out of old leaves before dropping them.
# We subtract this because they don't need to take this P from the soil.
leaf_re <- clean_flux("canopy_P_retranslocation_flux.csv", "canopy_p_retrans_flux", "Canopy_Re")
wood_re <- clean_flux("sapwood_P_retranslocation_flux.csv", "sapwood_p_retrans_flux", "Wood_Re")
root_re <- clean_flux("fineroot_P_retranslocation_flux.csv", "fineroot_p_retrans_flux", "Root_Re")
# C. Soil Supply (What microbes release)
# Note: This file format is slightly different (has 'Depth'), so we process manually
soil_supply <- read_csv("soil_p_mineralization_flux.csv", show_col_types = FALSE) %>%
mutate(Ring = factor(Ring), Year = year(Date)) %>%
filter(Year >= 2013 & Year <= 2016) %>%
group_by(Year, Ring, Date) %>%
summarise(Daily_Total = sum(p_mineralization_mg_m2_d, na.rm = TRUE), .groups="drop") %>%
group_by(Year, Ring) %>%
summarise(P_Mineralization_Supply = mean(Daily_Total) * 365 / 1000, .groups="drop")
# 3. CALCULATE THE BUDGET ---------------------------------------------------
# Combine all plant data
plant_budget <- bind_rows(wood_p, leaf_p, root_p, leaf_re, wood_re, root_re) %>%
group_by(Year, Ring) %>%
summarise(
Total_Demand = sum(Annual_Flux_g[Type %in% c("Wood", "Canopy", "Roots")]),
Total_Recycled = sum(Annual_Flux_g[Type %in% c("Canopy_Re", "Wood_Re", "Root_Re")]),
.groups = "drop"
) %>%
mutate(
# PLANT UPTAKE is Demand minus what they Recycled themselves
Plant_Uptake = Total_Demand - Total_Recycled
)
# Merge Plant Uptake with Soil Supply
final_data <- plant_budget %>%
left_join(soil_supply, by = c("Year", "Ring")) %>%
left_join(trt_map, by = "Ring") %>%
mutate(
# THE HEIST: If Supply is higher than Uptake, Microbes took it
Microbial_Stealing = P_Mineralization_Supply - Plant_Uptake
)
# 4. VISUALIZE THE RESULTS --------------------------------------------------
# Reshape for plotting
plot_data <- final_data %>%
pivot_longer(cols = c("P_Mineralization_Supply", "Plant_Uptake"),
names_to = "Flux_Type", values_to = "Grams_P_m2_yr")
ggplot(plot_data, aes(x = Trt, y = Grams_P_m2_yr, fill = Flux_Type)) +
geom_boxplot(alpha = 0.7) +
labs(
title = "Evidence of Microbial Competition",
subtitle = "Comparing Soil Supply vs. What Trees Actually Got",
y = "Phosphorus Flux (g P / m2 / year)",
x = "Treatment",
fill = "Flux Type"
) +
scale_fill_manual(values = c("P_Mineralization_Supply" = "#E69F00", "Plant_Uptake" = "#56B4E9"),
labels = c("Soil Supply (Microbes)", "Tree Uptake")) +
theme_minimal() +
theme(text = element_text(size = 14))
# Print the numbers to see the "Stealing"
print(final_data %>%
group_by(Trt) %>%
summarise(
Avg_Supply = mean(P_Mineralization_Supply),
Avg_Tree_Uptake = mean(Plant_Uptake),
Avg_Stolen_P = mean(Microbial_Stealing)
))
setwd("C:/Users/augre/Desktop/UPV S1/Data/2025Bgroup-phosphorusCO2/Flux_data")
library(tidyverse)
library(lubridate)
# 1. SETUP & TREATMENT MAPPING ---------------------------------------------
trt_map <- data.frame(
Ring = factor(c(1, 2, 3, 4, 5, 6)),
Trt = c("eCO2", "aCO2", "aCO2", "eCO2", "eCO2", "aCO2")
)
# 2. THE CORRECTED FUNCTION ------------------------------------------------
# Calculates total mass per year by integrating daily rates over specific time periods
# Then averages across the 6 years (2013-2018)
process_flux_correct <- function(file_path, val_col, item_name) {
df <- read_csv(file_path, show_col_types = FALSE) %>%
mutate(
Ring = factor(Ring),
Year = year(ymd(Date)) # Extract year from measurement date
) %>%
# Filter for the correct paper timeframe (2013-2018)
filter(Year >= 2013 & Year <= 2018)
# CALCULATION FIX:
# 1. Calculate total mass for *this specific period* (mg m-2)
# 2. Sum all periods in a year to get Annual Total (mg m-2 yr-1)
# 3. Convert to grams (div by 1000)
df_annual <- df %>%
mutate(Period_Mass_mg = get(val_col) * Days) %>% # Flux * Duration
group_by(Year, Ring) %>%
summarise(Annual_Sum_g = sum(Period_Mass_mg, na.rm = TRUE) / 1000, .groups = "drop") %>%
mutate(Type = item_name)
return(df_annual)
}
# 3. LOAD DATA (Phosphorus Budget Components) ------------------------------
# --- DEMAND (P needed for new growth) ---
# Note: Using standard column names found in EucFACE datasets
df_wood_dem  <- process_flux_correct("wood_p_flux.csv", "wood_p_flux", "Wood_Demand")
df_leaf_dem  <- process_flux_correct("canopy_p_flux.csv", "canopy_p_flux", "Canopy_Demand")
# For roots, use production flux
df_root_dem  <- process_flux_correct("fineroot_p_production_flux.csv", "fineroot_p_flux_mg_m2_d", "Root_Demand")
# --- RECYCLING (P retranslocated internally) ---
df_leaf_ret  <- process_flux_correct("canopy_P_retranslocation_flux.csv", "canopy_p_retrans_flux", "Canopy_Retrans")
df_wood_ret  <- process_flux_correct("sapwood_P_retranslocation_flux.csv", "sapwood_p_retrans_flux", "Wood_Retrans")
df_root_ret  <- process_flux_correct("fineroot_P_retranslocation_flux.csv", "fineroot_p_retrans_flux", "Root_Retrans")
# --- SUPPLY (Soil Mineralization) ---
# Soil data usually has depths. We must sum depths first, THEN time-integrate.
soil_raw <- read_csv("soil_p_mineralization_flux.csv", show_col_types = FALSE) %>%
mutate(Ring = factor(Ring), Year = year(ymd(Date))) %>%
filter(Year >= 2013 & Year <= 2018)
# Step A: Sum across depths for each specific date/ring to get Ecosystem Total
soil_daily_sums <- soil_raw %>%
group_by(Date, Ring, Year, Days) %>%
summarise(Daily_Flux_Total = sum(p_mineralization_mg_m2_d, na.rm = TRUE), .groups = "drop")
# Step B: Apply the time integration formula
df_soil_supply <- soil_daily_sums %>%
mutate(Period_Mass_mg = Daily_Flux_Total * Days) %>%
group_by(Year, Ring) %>%
summarise(Annual_Sum_g = sum(Period_Mass_mg, na.rm = TRUE) / 1000, .groups = "drop") %>%
mutate(Type = "Soil_Supply")
# 4. CALCULATE THE BUDGET --------------------------------------------------
# Combine all plant components
plant_components <- bind_rows(df_wood_dem, df_leaf_dem, df_root_dem,
df_leaf_ret, df_wood_ret, df_root_ret)
# Pivot to wide format to do math
budget_calc <- plant_components %>%
group_by(Year, Ring, Type) %>%
summarise(Value = sum(Annual_Sum_g, na.rm=TRUE), .groups="drop") %>%
pivot_wider(names_from = Type, values_from = Value, values_fill = 0) %>%
mutate(
# Total P needed by tree
Total_Demand = Wood_Demand + Canopy_Demand + Root_Demand,
# Total P recycled by tree
Total_Retrans = Canopy_Retrans + Wood_Retrans + Root_Retrans,
# Net P Uptake from Soil (The critical number)
Plant_P_Uptake = Total_Demand - Total_Retrans
) %>%
select(Year, Ring, Plant_P_Uptake)
# Join Uptake with Supply
final_analysis <- budget_calc %>%
left_join(df_soil_supply, by = c("Year", "Ring")) %>%
rename(Soil_P_Supply = Annual_Sum_g) %>%
left_join(trt_map, by = "Ring") %>%
mutate(
# The Gap: If Positive, Microbes are likely immobilizing the P
P_Gap = Soil_P_Supply - Plant_P_Uptake
)
# 5. VISUALIZATION & STATISTICS --------------------------------------------
# A. Visualizing the Fluxes
plot_data <- final_analysis %>%
pivot_longer(cols = c("Soil_P_Supply", "Plant_P_Uptake"),
names_to = "Flux_Pathway", values_to = "g_P_m2_yr")
ggplot(plot_data, aes(x = Trt, y = g_P_m2_yr, fill = Flux_Pathway)) +
geom_boxplot(alpha = 0.7, outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(jitter.width = 0.1), alpha = 0.4) +
labs(title = "The Microbial Bottleneck",
subtitle = "Comparison of Available Soil P (Supply) vs. Tree Uptake",
y = "Phosphorus Flux (g P m-2 yr-1)",
x = "Treatment") +
scale_fill_manual(values = c("Soil_P_Supply" = "#E69F00", "Plant_P_Uptake" = "#009E73"),
labels = c("Tree Uptake", "Soil Supply (Mineralization)")) +
theme_bw()
# B. Statistical Summary (Time-Averaged)
summary_table <- final_analysis %>%
group_by(Trt) %>%
summarise(
Avg_Supply = mean(Soil_P_Supply, na.rm = TRUE),
Avg_Uptake = mean(Plant_P_Uptake, na.rm = TRUE),
Avg_Gap_Microbial_Lock = mean(P_Gap, na.rm = TRUE)
)
print("--- Time-Averaged Ecosystem P Budget (2013-2018) ---")
print(summary_table)
# C. Is the gap significantly larger under eCO2? (Testing the hypothesis)
# If trees allocate C to roots but get no P, the gap might widen or stay same,
# but Uptake won't increase significantly.
t_test_gap <- t.test(P_Gap ~ Trt, data = final_analysis)
print(paste("P-value for CO2 effect on the P Gap:", round(t_test_gap$p.value, 4)))
setwd("C:/Users/augre/Desktop/UPV S1/Data/2025Bgroup-phosphorusCO2/Flux_data")
library(tidyverse)
library(lubridate)
# 1. SETUP & TREATMENT MAPPING ---------------------------------------------
trt_map <- data.frame(
Ring = factor(c(1, 2, 3, 4, 5, 6)),
Trt = c("eCO2", "aCO2", "aCO2", "eCO2", "eCO2", "aCO2")
)
# 2. THE CORRECTED FUNCTION ------------------------------------------------
# Calculates total mass per year by integrating daily rates over specific time periods
# Then averages across the 6 years (2013-2018)
process_flux_correct <- function(file_path, val_col, item_name) {
df <- read_csv(file_path, show_col_types = FALSE) %>%
mutate(
Ring = factor(Ring),
Year = year(ymd(Date)) # Extract year from measurement date
) %>%
# Filter for the correct paper timeframe (2013-2018)
filter(Year >= 2013 & Year <= 2018)
# CALCULATION FIX:
# 1. Calculate total mass for *this specific period* (mg m-2)
# 2. Sum all periods in a year to get Annual Total (mg m-2 yr-1)
# 3. Convert to grams (div by 1000)
df_annual <- df %>%
mutate(Period_Mass_mg = get(val_col) * Days) %>% # Flux * Duration
group_by(Year, Ring) %>%
summarise(Annual_Sum_g = sum(Period_Mass_mg, na.rm = TRUE) / 1000, .groups = "drop") %>%
mutate(Type = item_name)
return(df_annual)
}
# 3. LOAD DATA (Phosphorus Budget Components) ------------------------------
# --- DEMAND (P needed for new growth) ---
# Note: Using standard column names found in EucFACE datasets
df_wood_dem  <- process_flux_correct("wood_p_flux.csv", "wood_p_flux", "Wood_Demand")
df_leaf_dem  <- process_flux_correct("canopy_p_flux.csv", "canopy_p_flux", "Canopy_Demand")
# For roots, use production flux
df_root_dem  <- process_flux_correct("fineroot_p_production_flux.csv", "fineroot_p_flux_mg_m2_d", "Root_Demand")
# --- RECYCLING (P retranslocated internally) ---
df_leaf_ret  <- process_flux_correct("canopy_P_retranslocation_flux.csv", "canopy_p_retrans_flux", "Canopy_Retrans")
df_wood_ret  <- process_flux_correct("sapwood_P_retranslocation_flux.csv", "sapwood_p_retrans_flux", "Wood_Retrans")
df_root_ret  <- process_flux_correct("fineroot_P_retranslocation_flux.csv", "fineroot_p_retrans_flux", "Root_Retrans")
# --- SUPPLY (Soil Mineralization) ---
# Soil data usually has depths. We must sum depths first, THEN time-integrate.
soil_raw <- read_csv("soil_p_mineralization_flux.csv", show_col_types = FALSE) %>%
mutate(Ring = factor(Ring), Year = year(ymd(Date))) %>%
filter(Year >= 2013 & Year <= 2018)
# Step A: Sum across depths for each specific date/ring to get Ecosystem Total
soil_daily_sums <- soil_raw %>%
group_by(Date, Ring, Year, Days) %>%
summarise(Daily_Flux_Total = sum(p_mineralization_mg_m2_d, na.rm = TRUE), .groups = "drop")
# Step B: Apply the time integration formula
df_soil_supply <- soil_daily_sums %>%
mutate(Period_Mass_mg = Daily_Flux_Total * Days) %>%
group_by(Year, Ring) %>%
summarise(Annual_Sum_g = sum(Period_Mass_mg, na.rm = TRUE) / 1000, .groups = "drop") %>%
mutate(Type = "Soil_Supply")
# 4. CALCULATE THE BUDGET --------------------------------------------------
# Combine all plant components
plant_components <- bind_rows(df_wood_dem, df_leaf_dem, df_root_dem,
df_leaf_ret, df_wood_ret, df_root_ret)
# Pivot to wide format to do math
budget_calc <- plant_components %>%
group_by(Year, Ring, Type) %>%
summarise(Value = sum(Annual_Sum_g, na.rm=TRUE), .groups="drop") %>%
pivot_wider(names_from = Type, values_from = Value, values_fill = 0) %>%
mutate(
# Total P needed by tree
Total_Demand = Wood_Demand + Canopy_Demand + Root_Demand,
# Total P recycled by tree
Total_Retrans = Canopy_Retrans + Wood_Retrans + Root_Retrans,
# Net P Uptake from Soil (The critical number)
Plant_P_Uptake = Total_Demand - Total_Retrans
) %>%
select(Year, Ring, Plant_P_Uptake)
# Join Uptake with Supply
final_analysis <- budget_calc %>%
left_join(df_soil_supply, by = c("Year", "Ring")) %>%
rename(Soil_P_Supply = Annual_Sum_g) %>%
left_join(trt_map, by = "Ring") %>%
mutate(
# The Gap: If Positive, Microbes are likely immobilizing the P
P_Gap = Soil_P_Supply - Plant_P_Uptake
)
# 5. VISUALIZATION & STATISTICS --------------------------------------------
# A. Visualizing the Fluxes
plot_data <- final_analysis %>%
pivot_longer(cols = c("Soil_P_Supply", "Plant_P_Uptake"),
names_to = "Flux_Pathway", values_to = "g_P_m2_yr")
ggplot(plot_data, aes(x = Trt, y = g_P_m2_yr, fill = Flux_Pathway)) +
geom_boxplot(alpha = 0.7, outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(jitter.width = 0.1), alpha = 0.4) +
labs(title = "The Microbial Bottleneck",
subtitle = "Comparison of Available Soil P (Supply) vs. Tree Uptake",
y = "Phosphorus Flux (g P m-2 yr-1)",
x = "Treatment") +
scale_fill_manual(values = c("Soil_P_Supply" = "#E69F00", "Plant_P_Uptake" = "#009E73"),
labels = c("Tree Uptake", "Soil Supply (Mineralization)")) +
theme_bw()
# B. Statistical Summary (Time-Averaged)
summary_table <- final_analysis %>%
group_by(Trt) %>%
summarise(
Avg_Supply = mean(Soil_P_Supply, na.rm = TRUE),
Avg_Uptake = mean(Plant_P_Uptake, na.rm = TRUE),
Avg_Gap_Microbial_Lock = mean(P_Gap, na.rm = TRUE)
)
print("--- Time-Averaged Ecosystem P Budget (2013-2018) ---")
print(summary_table)
# C. Is the gap significantly larger under eCO2? (Testing the hypothesis)
# If trees allocate C to roots but get no P, the gap might widen or stay same,
# but Uptake won't increase significantly.
t_test_gap <- t.test(P_Gap ~ Trt, data = final_analysis)
print(paste("P-value for CO2 effect on the P Gap:", round(t_test_gap$p.value, 4)))
View(summary_table)
print(t.test(Root_to_Wood_Ratio ~ Trt, data = c_allocation)$p.value)
) --
# Note: Assume 'trt_map' and libraries are loaded (tidyverse, lubridate)
# 1. LOAD CARBON FLUXES (Corrected Aggregation) -----------------------------
# We use the corrected logic: Annual Flux = Sum(Daily_Flux * Days)
process_c_flux <- function(file, val_col, type_name) {
read_csv(file, show_col_types = FALSE) %>%
mutate(
Ring = factor(Ring),
# Use Date or Start_date for year extraction
Year = year(coalesce(ymd(Date), ymd(Start_date)))
) %>%
filter(Year >= 2013 & Year <= 2018) %>%
# Calculate Periodic Mass (assuming C data is already g/m2/d, as per your code)
mutate(Period_Mass_g = get(val_col) * Days) %>%
# Sum up to Annual Total
group_by(Year, Ring) %>%
summarise(Annual_C_g = sum(Period_Mass_g, na.rm=TRUE), .groups="drop") %>%
mutate(Component = type_name)
}
# Load All Components for Total Woody and Total Root Production
# A. Woody Production (Above-Ground Structural C)
df_wood_c <- process_c_flux("wood_c_production_flux.csv", "wood_production_flux", "Wood")
df_bark_c <- process_c_flux("barklitter_c_production_flux.csv", "bark_litter_flux", "Bark")
df_twig_c <- process_c_flux("twiglitter_c_production_flux.csv", "twig_litter_flux", "Twig")
# 1. LIBRARIES ------------------------------------------------------------
library(tidyverse)
library(lubridate)
library(lme4)      # For Linear Mixed-Effects Models
library(lmerTest)  # To get p-values from LME models
library(patchwork) # For plotting
# 2. SETUP & HELPER FUNCTION ----------------------------------------------
trt_map <- data.frame(
Ring = factor(c(1, 2, 3, 4, 5, 6)),
Trt = c("eCO2", "aCO2", "aCO2", "eCO2", "eCO2", "aCO2")
)
# Corrected Integration Function (Flux * Days / 1000)
process_c_flux <- function(file_path, val_col, item_name) {
read_csv(file_path, show_col_types = FALSE) %>%
mutate(Ring = factor(Ring), Year = year(ymd(Date))) %>%
filter(Year >= 2013 & Year <= 2018) %>%
mutate(Period_Mass_g = get(val_col) * Days) %>% # Integrate over time
group_by(Year, Ring) %>%
summarise(Annual_Sum_g = sum(Period_Mass_g, na.rm=TRUE), .groups="drop") %>%
mutate(Component = item_name)
}
# 3. LOAD ALL COMPREHENSIVE DATA COMPONENTS -------------------------------
# --- BELOWGROUND (Total Root Investment) ---
# 1. Fine Roots (Foraging)
df_fr <- process_c_flux("fineroot_c_production_flux.csv", "fineroot_production_flux", "FineRoot")
# 2. Coarse Roots (Structural)
df_cr <- process_c_flux("coarse_root_c_production_flux.csv", "coarse_root_production_flux", "CoarseRoot")
# --- ABOVEGROUND (Total Woody Investment) ---
# 3. Wood (Stem Increment)
df_wood <- process_c_flux("wood_c_production_flux.csv", "wood_production_flux", "Wood")
# 4. Bark Litter
df_bark <- process_c_flux("barklitter_c_production_flux.csv", "bark_flux", "Bark")
# 5. Twig Litter
df_twig <- process_c_flux("twiglitter_c_production_flux.csv", "twig_flux", "Twig")
# 6. Seed/Reproduction
df_seed <- process_c_flux("seedlitter_c_production_flux.csv", "seed_flux", "Seed")
# 4. AGGREGATE THE BUDGET -------------------------------------------------
# Combine all dataframes
all_c_fluxes <- bind_rows(df_fr, df_cr, df_wood, df_bark, df_twig, df_seed)
# Pivot and Calculate Allocations
c_allocation_full <- all_c_fluxes %>%
pivot_wider(names_from = Component, values_from = Annual_Sum_g, values_fill = 0) %>%
mutate(
# The Correct Denominator: Total Woody C
Total_Woody_C = Wood + Bark + Twig + Seed,
# The Correct Numerator: Total Root C
Total_Root_C = FineRoot + CoarseRoot,
# The Ecological Metric: Shift in Allocation
Root_to_Wood_Ratio = Total_Root_C / Total_Woody_C
) %>%
left_join(trt_map, by = "Ring")
# 5. VISUALIZATION (Comprehensive Budget) ---------------------------------
# Plot A: Total Woody Production (Stagnation Check)
p1 <- ggplot(c_allocation_full, aes(x=Trt, y=Total_Woody_C, fill=Trt)) +
geom_boxplot(alpha=0.5) +
geom_jitter(width=0.1, alpha=0.6) +
labs(title="1. Total Woody Output", subtitle="(Stem+Bark+Twig+Seed)", y="g C m-2 yr-1") +
theme_bw() + theme(legend.position="none")
# Plot B: Total Root Production (Foraging Check)
p2 <- ggplot(c_allocation_full, aes(x=Trt, y=Total_Root_C, fill=Trt)) +
geom_boxplot(alpha=0.5) +
geom_jitter(width=0.1, alpha=0.6) +
labs(title="2. Total Root Output", subtitle="(Fine + Coarse)", y="g C m-2 yr-1") +
theme_bw() + theme(legend.position="none")
# Plot C: The Allocation Ratio
p3 <- ggplot(c_allocation_full, aes(x=Trt, y=Root_to_Wood_Ratio, fill=Trt)) +
geom_boxplot(alpha=0.5) +
geom_jitter(width=0.1, alpha=0.6) +
labs(title="3. Adaptability Strategy", subtitle="Ratio: Total Roots / Total Wood", y="Ratio") +
theme_bw() + theme(legend.position="none")
p1 + p2 + p3
# 6. CORRECT STATISTICS (Linear Mixed-Effects Models) ---------------------
# We use lmer() to account for:
# 1. Fixed Effect: Trt (eCO2 vs aCO2)
# 2. Fixed Effect: Year (Accounting for inter-annual climate variability)
# 3. Random Effect: (1|Ring) (Accounting for repeated measures on the same plot)
run_lme <- function(formula, data, metric_name) {
print(paste("--- LME Results for:", metric_name, "---"))
model <- lmer(formula, data = data)
print(anova(model)) # Returns the F-statistics and P-values
}
# Test 1: Did Wood Production Stagnate? (Expect P > 0.05 for Trt)
run_lme(Total_Woody_C ~ Trt + as.factor(Year) + (1|Ring), c_allocation_full, "Woody Production")
# Test 2: Did Root Production Increase? (Expect P < 0.05 or trend)
run_lme(Total_Root_C ~ Trt + as.factor(Year) + (1|Ring), c_allocation_full, "Root Production")
# Test 3: Did the Allocation Strategy Shift? (Expect P < 0.05)
run_lme(Root_to_Wood_Ratio ~ Trt + as.factor(Year) + (1|Ring), c_allocation_full, "Root:Wood Ratio")
# Now combine them again
p1 + p2 + p3
# Now combine them again
p1 / p2 / p3
p1 / p2 / p3
p1 / p2 / p3
p1 / p2 / p3
p1 / p2 / p3
p1 / p2 / p3
# CRITICAL STEP: Save the file to ensure it looks good
# Making the height larger (e.g., 10) prevents the titles from crunching together
ggsave("Analysis_Results_Stacked.png", final_plot, width = 6, height = 10)
Plot A: Total Woody Production
